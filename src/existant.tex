\chapter{État de l'art}
L'état de l'art des domaines relatifs à ce stage s'intéressera à trois aspects : 
\begin{itemize}
	\item Les avancées en réseaux de Petri, qui sont au cœur du modèle.
	\item Les avancées en terme de répartition, et de synchronisation en temps entre machines.
	\item L'état actuel du projet \ac{OSSIA}. 
\end{itemize}

Quand ils ne sont pas semblables au français, les noms anglais des termes scientifiques employés seront marqués en \textit{italique}.

\section{Réseaux de Petri}
Les réseaux de Petri\cite{petri1962kommunikation} sont au cœur du formalisme utilisé ici. Néanmoins, une différence majeure entre leur utilisation dans le projet \ac{OSSIA} avec d'autres utilisations plus courante est que pour \ac{OSSIA}, les réseaux ne servent pas à faire de l'analyse statique mais sont au cœur du moteur d'exécution du programme. C'est-à-dire que la théorie des scénarios a été développée de manière à pouvoir être exprimée en terme de réseaux de Petri, et que ces réseaux de Petri sont ensuite exécutés avec un algorithme relativement simple, qui sera détaillé plus tard dans ce document.

La conférence principale sur le thème des réseaux de Petri est l'\textit{International Conference on Application and Theory of Petri Nets and Concurrency}, qui présente cette année sa 35\ieme édition.

\subsection{Familles de réseaux de Petri}
À l'origine, les réseaux portaient le nom de réseaux places-transitions. La définition la plus simple est celle d'un graphe orienté biparti, dont les deux parties sont les places, et les transitions.

Les places contiennent des jetons; quand les places antécédentes à une transition possèdent toutes au moins un jeton, celle-ci est dite \textit{sensibilisée}. Elle peut alors s'exécuter (on dit qu'elle est \textit{tirée}) en enlevant un jeton à chaque place la précédant et en rajoutant un jeton à chaque place la suivant.

Plusieurs cours et livres récents présentent les généralités des réseaux de Petri \citep[voir][]{david2010discrete, diaz2013petri}, avec les notations et vocabulaires contemporains.

Néanmoins, étant un formalisme facilement extensible, plusieurs modifications des réseaux de Petri ont prouvé leur intérêt; elles seront vues plus en détail dans les prochains paragraphes.
\subsubsection{Réseaux hiérarchiques}
L'idée de base des réseaux hiérarchiques consiste à avoir des sous-réseaux qui s'exécutent lorsqu'un jeton arrive dans une place.

Une extension aux transitions existe, en utilisant la notion de blocs de construction\cite{fehling1993concept}.

Actuellement, l'essentiel de la recherche dans ce domaine consiste en la recherche de formalisations pouvant généraliser les différents concepts de modularité, comme par exemple \brand{LLAMAS} (Language for Advanced Modular Algebraic Nets)\cite{colom2013application}.

Les réseaux hiérarchiques sont principalement utilisés pour modéliser des systèmes complexes du monde réel, dans des cas industriels par exemple.

\subsubsection{Réseaux colorés}
Les réseaux colorés\cite{zervos1977colored,jensen1987coloured} ont été une des premières extensions des réseaux de Petri. L'idée principale est de permettre aux jetons d'être porteurs de donnée, à l'aide des couleurs. 

Les transitions peuvent créer des jetons de couleur, et les arcs possèdent des fonctions d'arc laissant passer les couleurs choisies.

La notion de hiérarchie a été étendue aux réseaux colorés de plusieurs manières différentes \cite{rozenberg1991advances}, qui sont à choisir en fonction des cas d'utilisation.

Une généralisation des réseaux colorés porte le nom de réseaux de haut niveau (\textit{high-level Petri nets}) \cite{jensen1983high}. Elle remplace la notion de couleur par celle de type, plus extensible.
Il est possible de convertir des machines à état \brand{UML} en réseaux de Petri de haut niveau en utilisant un algorithme génétique \cite{alhroob2014transforming}.

\subsubsection{Réseaux liés au temps}
Il existe plusieurs manières d'introduire la notion de temps dans les réseaux de Petri.
\begin{itemize}
\item La première méthode a été celle des réseaux temporisés (\textit{timed Petri net}) : les places ou transitions portent les durées des actions qu'elles simulent. C'est le cas d'i-score.

\item Peu après a été établi le formalisme des réseaux temporels (\textit{time Petri net}) : les éléments du réseau (place ou transition) peuvent avoir une date minimale et maximale d'exécution.
Une extension récente \cite{klai2013temporal} au dessus des réseaux temporels  présente un moyen d'encoder le temps minimal et maximal écoulé à chaque instant, ainsi que les avantages que cela peut avoir.

\item Enfin, le modèle relatif au temps le plus récent utilise les opérateurs de logique temporelle \cite{logic2002temporal,suzuki1989temporal}. L'avantage par rapport aux modèles temporels et temporisés est une meilleure représentation des propriétés de vivacité (\textit{liveness}).
\end{itemize}
\paragraph{Réseaux stochastiques}
Les réseaux de Petri stochastiques \cite{bause1996stochastic} sont d'une certaine manière reliés au temps.

Dans ce type de réseau, les transitions franchissables sont activées après un délai déterminé par une variable aléatoire.
 
\subsubsection{Réseaux flous}
Les réseaux de Petri flous (\textit{fuzzy Petri nets}) \cite{pedrycz1994generalized} sont une classe de réseau de Petri inspirés des réseaux neuronaux. Leur utilité principale est comme pour les réseaux neuronaux l'apprentissage informatique.

Une approche récente utilise les réseaux de Petri flous pour modéliser des systèmes à connaissance floue\cite{wang2014dynamic}, et plus généralement les systèmes de modélisation de la connaissance, en prenant en compte la notion d'incertitude.

\subsection{Standardisation}
Il est assez apparent au vu de la section précédente que les variations autour du formalisme de base sont assez ample, et que beaucoup d'extensions sont possibles.

Un effort de standardisation est mené depuis le début des années 2000 pour avoir un format d'échange commun à différents outils, avec le langage \ac{PNML}.

Cet effort a abouti en 2008 et 2011 avec la standardisation dans la norme ISO/IEC 15909-2.

Le langage est basé sur du \brand{XML}, avec une attention importante à la modularité. Il a été conçu à l'aide de \glspl{metamodel} \brand{UML}.

Un état de l'art\cite{hillah2010standardisation} a été dressé par les auteurs du langage en 2010.

L'accent actuel est mis sur la gestion de la modularité, avec l'implémentation des concepts de hiérarchie, ou d'encapsulation. Ce travail est réalisé dans \brand{Modular PNML}. Un méta-modèle pour représenter les réseaux de Petri modulaires est en cours d'étude\cite{marechal2012modular}.

\subsection{Outils développés pour l'analyse des réseaux de Petri}
En sus de la théorie bâtie depuis bientôt un demi-siècle, les réseaux de Petri sont aussi très utilisé en pratique, pour réaliser des simulations de systèmes à complexité variable.

(TODO mettre captures d'écran ?)

\subparagraph{ePNK} est une plateforme logicielle travaillant en format PNML. Elle est bâtie autour de la notion d'extensibilité, en permettant aux autres développeurs d'insérer facilement leurs propres formalismes de réseaux de Petri avec une architecture en plug-in.

À la base prévue pour l'édition, elle est aussi désormais capable de simuler l'exécution de réseaux de Petri  \cite{kindler2013simulator}.

\subparagraph{PetriNet API} \cite{lohmann2009petri} est une interface de programmation en \brand{C++} offrant aux développeurs des structures de données simples (place, transition, réseau de Petri) permettant de bâtir leurs propres outils par dessus.

Un des avantages est l'import de données au format \ac{PNML} et l'export au format \brand{DOT} de \gls{graphviz}, à des fins de visualisation.

\subparagraph{CPN Tools} (\textit{Colored Petri Net Tools}) permet comme \brand{ePNK} d'éditer, simuler, et analyser des réseaux de Petri colorés \cite{jensen2007coloured}.

Il est notamment utilisé dans le projet \ac{OSSIA} à des fins de validation.

\subparagraph{PNlib}  \cite{pross2014object} est un outil de simulation orienté objet visant le cas particulier des processus biologiques.

\brand{PNlib} a été réalisé en \gls{modelica} et s'y intègre facilement.

\subparagraph{Snoopy} \cite{heiner2012snoopy} est un autre cadre logiciel à vocation unificatrice, permettant aussi l'utilisation de la couleur. Il supporte la hiérarchie.

Des outils d'analyse dynamique sont intégrés au logiciel.

Il a été appliqué aux réseaux biomoléculaires \cite{rohr2010snoopy}.

Une des particularités du logiciel est d'avoir plusieurs vues pour le même modèle, et d'aleterner facilement entre ces vues. Par exemple, il est possible d'avoir un modèle stochastique et un modèle continu pour le même réseau, qui partagent certaines propriétés.

\subsection{Applications récentes}
Il serait très dur d'établir un inventaire complet des utilisations des réseaux de Petri : comme pour les automates, les machines de Turing, ou encore le lambda-calcul, c'est un outil avec une très forte puissance d'expression, qui peut donc être utilisé dans une variété d'environnements différents, à des fins de modélisation.

Par exemple, à l'origine, C. A. Petri avait conçu les réseaux qui portent aujourd'hui son nom afin de modéliser des réactions chimiques. Ils sont maintenant très utilisés dans les modélisations de comportements biologiques \cite{koch2014petri}.

\subsubsection{Parallélisme}
Une des applications les plus courantes des réseaux de Petri est de simuler des systèmes répartis.

Un domaine annexe est celui de la parallélisation. Récemment, des progrès ont été fait dans la gestion de l'ordonnancement dans le cas d'applications s'exécutant en parallèle\cite{chen2014research}. Notamment, le système est modélisé à l'aide d'un réseau de Petri, et un algorithme génétique est utilisé pour y rechercher un chemin permettant un temps d'exécution minimal. 

\subsubsection{Application aux interfaces homme-système}
Les réseaux de Petri peuvent servir à modéliser toutes sortes de systèmes se basant sur une succession d'évènements.
 
Ils ont par exemple été utilisés pour la modélisation des interactions homme-système\cite{campos2014elementary}, avec différentes catégories d'évènements, comme le dépassement d'un seuil ou l'émission d'un signal, ce qui permet par la suite d'effectuer une analyse statique qui pourrait montrer des failles dans la conception du dit système.

\subsubsection{Application à des modèles cyber-physiques}
La \gls{cyberphysique} peut tirer un certain bénéfice des réseaux de Petri pour la simulation de son bon fonctionnement. En effet, elle consiste en différents éléments répartis et communiquants.

Des réseaux de Petri spatio-temporels ont été introduits\cite{zhang2014modeling} pour gérer les aspects de déplacements physique au cours du temps dans ce cas.

\section{Répartition}
La répartition (\textit{distribution}) est un second point important de ce stage. C'est un domaine qui est souvent très proche de la technique : le besoin d'utiliser des algorithmes répartis provient souvent de contraintes matérielles ou temporelles.

\subsection{Ouvrages de référence}
Plusieurs livres sont dédiés à des présentations générales du sujet, celui-ci étant étudié depuis plusieurs décénnies.

Au niveau des algorithmes, le livre de Nancy Lynch \cite{lynch1996distributed} présente les cas et problèmes les plus courants, en séparant les méthodes synchrones et asynchrones. 

Un autre ouvrage \cite{attiya2004distributed} met plus l'accent sur la simulation d'algorithmes distribués.

Data-Aware Distributed Computing

\subsection{Vérification}
A Logic-Based Framework for Verifying Consensus Algorithms

Message-Passing Algorithms for the Verification of Distributed Protocols

FlockLab: a testbed for distributed, synchronized tracing and profiling of wireless embedded systems
\subsection{Développment}
Cette partie traitera des publications récentes ayant trait à l'implémentation des algorithmes de répartition.

Un ouvrage récent \cite{varela2013programming} fait le lien entre la théorie et la pratique, en présentant les méthodes les plus récentes pour écrire certains algorithmes. Un accent est mis sur la manière dont différents langages de programmation vont permettre plus ou moins simplement de réaliser différents paradigmes. Il tient aussi compte des avancées sur le \gls{calculambiant}, le \gls{picalcul}, et le \gls{joincalcul}.

Modularity in the design of robust distributed algorithms

Fully Distributed Algorithms for Minimum Delay Routing Under Heavy Traffic 

Distributed Mutual Exclusion Algorithms for Intersection Traffic Control

\subsection{Réseaux sans-fil}
Exploiting wireless broadcast property to improve performance of distributed algorithms and mac protocols in wireless networks
\section{Synchronisation}

\subsection{Synchronisation logique}
\subsubsection{Origines : les horloges de Lamport}
\subsubsection{Horloges vectorielles}

\subsection{Synchronisation physique}
\subsubsection{Algorithmes couramment utilisés}
\paragraph{NTP}
\ac{NTP}
\paragraph{PTP}
\ac{PTP}
Cf. articles sur précision sur Android : 
A Measurement of Time synchronization on Mobile Devices.

Comparer avec NTP + implémentation existantes.

\subsubsection{Travaux plus récents}
(TODO mieux catégoriser)
Distributed synchronization under uncertainty: A fuzzy approach

Fine-grained network time synchronization using reference broadcasts

Subscription-Notification mechanisms for synchronization of distributed states

One Clock to Rule Them All: A Primitive for Distributed Wireless Protocols at the Physical Layer

Distributed network synchronization: the internet and electric power grids

Riccati Design for Synchronization of Discrete-Time Systems (bof)

Riccati Design for Synchronization of Continuous-Time Systems

Time Synchronization for High Latency Acoustic Networks


\subsection{Estimation de la latence}
\label{section:latence}
Network latency estimation % http://www.google.com/patents/US8254264B1

King: estimating latency between arbitrary internet end hosts

Method and system for peer-to-peer network latency measurement % http://www.google.com/patents/US6012096


\section{Projet OSSIA}
(Présentation travaux Allombert, Toro, Arias, etc.)

Modelling Data Processing for Interactive Scores Using Coloured Petri Nets
\subsection{Les réseaux de Petri dans OSSIA}
\subsection{Scénarios interactifs}
\subsection{Temps souple}
\subsection{Exemple dans le formalisme OSSIA}

