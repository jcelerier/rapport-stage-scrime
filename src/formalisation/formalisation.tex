\chapter{Apports au problème}
\label{chapterApports}
\section{Introduction}
Le but de cette partie est de fournir une sémantique  personnalisée pour la distribution de l'exécution d'un réseau de Petri sur un réseau informatique, en prenant en compte les délais dûs à la répartition physique des machines et les contraintes issues du projet \ac{OSSIA}.

\subsection{Rappel du formalisme}
Le formalisme de base utilisé est celui des réseaux de Petri t-temporisés, disposant d'un couple place $\rightarrow$ transition initiale et transition $\rightarrow$ place finale, avec pour restriction le fait qu'une place ne puisse posséder qu'une entrée et qu'une sortie, et ce pour éviter les problèmes de conflits et confusions : cela en fait des graphes d'évènements\cite[p. 7--9]{david2010discrete}. L'utilisation de la couleur est possible.

Les réseaux de Petri utilisés ici sont connexes : la seule place n'étant pas en sortie de transition est la place initiale, et la seule place n'étant pas en entrée de transition est la place finale.

\subsubsection{Algorithme d'exécution de base}
(TODO rédiger avec algorithm2e)
Un jeton est placé dans la place initiale, le temps est initialisé à 0. Une horloge est initialisée.

Pour chaque transition, si elle est sensibilisée, et que la somme des durées entre elle et la place initiale est écoulée, alors elle est franchie.

Quand tous les jetons ont franchi la transition menant à la place finale, l'algorithme termine.

\paragraph{Note} Il est possible que l'algorithme ne termine pas : en effet, on pourrait vouloir un scénario en boucle infinie, pour une installation artistique par exemple.

\subsection{Démarche suivie}
La première étape de mon travail a été de rechercher l'existant proche du cas présent. Néanmoins, malgré diverses rencontres avec des professeurs spécialisés dans le domaine des automates et des réseaux, et une recherche bibliographique sur ce sujet, aucun autre cas de moteur d'exécution de réseau de Petri n'a été trouvé.

Ainsi, ma recherche s'est plutôt portée sur les moyens de répartir des algorithmes à la base prévus pour une utilisation sur une seule machine. 

L'idée principale a été de lancer les exécutions des sous-scénarios répartis sur d'autres machines en avance.

Cela engendre deux problèmes : 
\begin{itemize}
\item Comment estimer le retard entre deux machines ?
\item Comment modifier les réseaux de Petri de manière à ce qu'ils prennent en compte le départ en avance qui en découle ?
\end{itemize}

C'est surtout le second qui est au cœur de cette partie, le premier étant couvert de manière extensive par la littérature scientifique.

Trois idées différentes pour parvenir à ce but sont présentées : deux qui se basent sur la modification de la topologie du réseau, et une qui se base sur la modification de la sémantique du réseau.

De plus, la notion de segment est introduite, qui est une légère abstraction permettant de représenter simplement les processus dans les réseaux de Petri.

\section{Définitions}
Un des problèmes de vocabulaire principal dans ce document est que nous faisons référence à deux types de réseaux tout à fait distincts : les réseaux de Petri, et les réseaux informatiques présents dans le monde physique.

Pour pallier ce problème, nous utiliserons de préférence l'idée de graphe et de nœuds quand il s'agit de réseau informatique, et l'idée de réseau quand il s'agit de réseau de Petri.

\subsection{Définitions relatives aux réseaux physiques}
\begin{mydef}[Réseau informatique]
Un réseau informatique est représenté par un graphe orienté $G$ dont les nœuds représentent les machines, et les arêtes les liens entre ces machines. 

Les arêtes sont étiquetées par un temps $\delta$, signifiant le temps de transmission d'un message entre les deux nœuds attenants à l'arête.
\end{mydef}
$\delta$ sera considéré fixe. Néanmoins, dans un scénario réel, il serait envisageable (et recommandé) de mesurer et corriger $\delta$ régulièrement en raison de la latence entre les nœuds qui peut varier, notamment à l'aide des méthodes présentées en partie \ref{section:latence}.
\\
\begin{mynot}
	Soient $N_1$ et $N_2$ deux nœuds du graphe. On note $\delta_{N_1 \rightarrow N_2}$ le temps de transmission entre $N_1$ et $N_2$.
\end{mynot} 

Bien que dans de nombreux cas, $\delta_{N_1 \rightarrow N_2} \simeq \delta_{N_2 \rightarrow N_1}$, nous ne ferons pas cette supposition ici. En revanche, nous considérerons toujours des liens en duplex.

Les nœuds de $G$ peuvent contenir des places et des transitions. Si un nœud contient une transition, on dit qu'il l'\textit{exécute}.

\subsection{Définitions relatives aux réseaux de Petri}
\begin{mydef}[Segment]
Un segment est composé d'une transition, de ses $N$ places d'entrées, et de ses $M$ places de sortie, avec $N \geq 1, M \geq 1$.
\end{mydef}

On notera que mis à part les segments initiaux et finaux, tous les segments partagent au moins une place avec un autre segment.

L'approche utilisée dans les schémas de ce document est de représenter un segment par ses places d'entrée et sa transition.

\begin{mynot}
On note $\entree(s)$ l'ensemble des places d'entrée de $s$, $\sortie(s)$ l'ensemble des places de sortie de $s$.
\end{mynot}

\begin{mynot}
On note $\pre(s)$ l'ensemble des segments précédant le segment $s$, $\post(s)$ l'ensemble des segments suivant $s$.
\end{mynot}

\begin{mynot}
On note $\shared(s_1, s_2)$ les places en sortie de $s_1$ et en entrée de $s_2$.
\end{mynot}

\section{Méthodes par modification de la topologie}
\chaptermark{Premières méthodes}
Ces formalisations se font par modification de la topologie du réseau de Petri. C'est-à-dire que des places, arcs, et transitions vont être rajoutées au réseau pour encoder la notion de départ en avance.

\subsection{Définitions}
\subsubsection{Définition des opérations de transformation de base}
Deux niveaux d'opération sont décrits dans ce document.

Ici, on décrit les opérations atomiques pouvant être exécutées sur les segments, qui ne tiennent pas compte de la répartition. 

Par la suite, chaque méthode comportera ses propres opérations, qui serviront spécifiquement à appliquer la répartition. 

Toutes ces opérations seront écrites en police informatique : \texttt{maFonction(x)}.

Il convient de noter que les opérations appliquant la répartition sont réversibles. Ainsi, il est toujours possible d'appliquer les opérations atomiques sans avoir besoin de tenir compte de la répartition : il suffit d'inverser ces dernières, d'appliquer les opérations atomiques, puis de ré-appliquer les opérations de répartition effectuées, si possible (un cas impossible serait celui ou on voudrait supprimer un segment qui était réparti).

\paragraph{Création}
On considère la fonction \texttt{crée(d, nPlacesEntrée, nPlacesSortie)}. Elle permet de créer un segment, de durée \texttt{d} et avec un nombre explicite de places d'entrée et de sortie.

\begin{itemize}
\item \texttt{d} peut être une durée variable.
\item \texttt{nPlacesEntrée} $ \geq 1 $ et \texttt{nPlacesSortie} $ \geq 1 $.
\end{itemize}
\paragraph{Lien}
Le lien crée un arc entre deux segments.

On définit : \texttt{lie(sOrigine, pDestination)} qui crée un arc entre la transition du segment \texttt{sOrigine}, et la place \texttt{pDestination}.

De même, \texttt{délie(sOrigine, pDestination)} supprime un arc.

\paragraph{Suppression}
(TODO processus sur place partagée?)
\texttt{suppr(s)} supprime le segment, ainsi que les arcs en entrée et en sortie.

Si un segment ne se retrouve plus relié à rien suite à cette opération, une place d'entrée lui est rajoutée, qui est reliée en sortie de la transition initiale.

\subsubsection{Définition de segments particuliers}
(TODO cela aurait-il sa place dans la partie plus générale ? Moins utilisé dans formalisation par couleur...)

Ces segments relient les notions de graphe de machines et de réseau de Petri.
\begin{mydef}[nd-transition]
Une transition non-distribuée, notée nd-transition, correspond à une transition dont aucune des places d'entrée ou de sortie ne sont situées sur un autre nœud du graphe.
\end{mydef}

\begin{mydef}[d-transition]
Une transition distribuée, notée d-transition, correspond à une transition dont une des places d'entrée ou de sortie est située sur un autre nœud du graphe.
\end{mydef}

\begin{mydef}[nd-segment]
Un d-segment (resp. nd-segment) est un segment bâti autour d'une d-transition (resp. nd-transition).
\end{mydef}

\begin{mydef}[Segments consécutifs]
Deux segments sont dits consécutifs s'ils partagent au moins une place. Cela implique qu'au moins une place de sortie de l'un soit une place d'entrée de l'autre.
\end{mydef}

Un réseau de Petri distribué contient des d-segments et des nd-segments consécutifs, ainsi qu'une place initiale et une place finale.

Des processus existent de plus au-dessus de segments, qui sont signifiés par un changement d'état d'un paramètre entre deux places. Il est donc important d'assurer que la durée de ces processus ne change pas lors de la distribution. (TODO déplacer dans pbq)

\subsection{Première tentative de formalisation}
Cette section présente la première idée qui a été pensée pour résoudre ce problème.

L'idée principale est d'exécuter les segments en les coupant au moment ou les segments suivants sont sensés partir en considérant les délais de transmission entre nœuds, puis de continuer leur exécution dans un autre segment.
 
\subsubsection{Opérations définies sur segment}
On considère que dans l'état initial du système, tous les segments sont situés sur le même nœud.

\paragraph{Déplacement}
L'opération de déplacement consiste à déporter l'exécution d'un nd-segment d'un nœud vers un autre, en transformant le réseau pour s'accommoder des délais.

\subparagraph{Processus} ~ \\

On note $s$ le segment à déplacer.
Pour tout segment $p \in \pre(s)$ : 

\begin{enumerate}
\item Soit $t_p$ la durée de la transition de $p$. On change cette durée en $t_p - \delta$.
\item On rajoute une place en sortie de $p$ ainsi qu'une transition $T$ de durée $\delta$ à la suite de cette place. 

Pour tout segment $o$ appartenant à $\post(p)$ à l'exception de $s$, on supprime les arcs entre $o$ et $p$, puis on crée des arcs allant de $T$ aux places d'entrée de $o$.

On duplique de plus toute place appartenant à $\shared(p, s)$, en sortie de $T$, de manière à garder l'ancienne position de $s$ en mémoire pour annuler le déplacement si nécessaire.

On notes cet ensemble de places dupliquées $\memory(s, p)$ (la mémoire des places d'origine lors du déplacement de $s$ par rapport à $p$).
 
\item On déplace l'information de fin de processus potentiellement contenue sur les places de $\shared(p, s)$ vers les places  $\memory(s, p)$. Cela permet d'avoir les évènements de fin de processus attenants à $p$ exécutés sur le même nœud que $p$.
\end{enumerate}

Puis, on applique la même opération entre $s$ et les segments appartenant à $\post(s)$, pour avoir une compensation de délai par rapport aux nœuds des segments suivant $s$.

Un exemple graphique est présenté en figure \ref{fig:deplacementMethode1}.

\begin{figure}[h!]
\centering
\input{formalisation/figures/deplacementMethode1}
\caption{Exemple : déplacement, première méthode}
\label{fig:deplacementMethode1}
\end{figure}

\paragraph{Recombinaison}
L'opération de recombinaison intervient quand un segment est déplacé sur un nœud où un autre segment avec lequel il partage une place est présent.
La recombinaison consiste en la fusion entre les places de $\shared(p, s)$ et de  $\memory(s, p)$ de telle sorte que le temps de démarrage du second segment soit inchangé.

La recombinaison est l'opération inverse du déplacement.

\subsubsection{Problèmes}
Il y a un problème majeur avec cette approche : la soustraction qui est effectuée à la durée de la transition de $p$. En effet, si on désire effectuer plusieurs opérations de déplacement successives, on peut arriver rapidement à une durée de transition négative, ce qui n'est pas acceptable. 

Cela est dû au fait que les transitions de $\pre(s)$ sont brisées en deux (ou plus) sous-transitions, de durées inférieures.

Il faut donc chercher une méthode qui permette plus de souplesse, et qui préserve les nd-segments dans leur forme originale.

\subsection{Seconde tentative de formalisation}
Cette formalisation est similaire à la précédente, car elle change aussi la topologie. Néanmoins, elle permet une plus grande flexibilité et ne pose pas de problèmes en cas d'enchaînements de déplacements.
Elle est cependant plus complexe à mettre en œuvre.

L'idée est la suivante : nous allons introduire deux segments spéciaux, ayant chacun un but distinct.

Le premier servira à dupliquer l'exécution d'un segment en en créant plusieurs branches pouvant s'exécuter en parallèle, en étant placées en précédence d'un segment réel (contenant un processus) ou fictif.

Le second servira à ajuster la durée des processus fictifs, ce qui permet d'ajuster l'instant auquel démarre le segment à déplacer par rapport aux contraintes du réseau.

Enfin, un troisième segment sera introduit plus tard, en partie \ref{section:synchroPetri}, permettant de synchroniser la fin des branches.

\subsubsection{Segments spéciaux}
\label{section:alphasegment}
\begin{mydef}[$\alpha$-segment]
Un $\alpha$-segment est un nd-segment particulier de durée $0$, possédant au moins deux places de sortie et une place d'entrée.
\end{mydef}
Un $\alpha$-segment peut être créé en précédence d'un segment $s$ de la manière suivante : 
\begin{enumerate}
\item Une transition $T_\alpha$ de durée 0 est créée. Toutes les places d'entrée de $s$ sont déconnectées de $s$ et placées en entrée de $T_\alpha$.
\item Une place est créée en sortie de $T_\alpha$ et en entrée de $s$. 
\end{enumerate}

Le rôle des $\alpha$-segments est de permettre à un segment d'être suivi par un nombre quelconque d'autres segments s'exécutant sur d'autres nœuds, avec des délais différents entre les nœuds.

Dans les schémas qui suivent, il sera représenté en \textcolor{BrickRed}{rouge}.

\begin{mydef}[$\beta$-segment]
Un $\beta$-segment est un d-segment particulier dont la durée vaut celle d'un autre segment moins un délai variable. Il précède nécessairement un nd-segment, et ne peut en être dissocié.
\end{mydef}
Son rôle est de simuler l'exécution d'un autre segment en ajustant sa durée de manière à ce qu'elle prenne en compte le lien entre deux nœuds, lorsque deux segments consécutifs sont placés sur deux nœuds différents.

Dans les schémas qui suivent, il sera représenté en \textcolor{OliveGreen}{vert}.
\subsubsection{Opérations définies sur segments}
\paragraph{Déplacement et recombinaison}

Il convient de noter que l'opération de déplacement ne peut produire, dans l'idéal, de résultats identiques aux cas non répartis que : 
\begin{itemize}
\item Si le délai entre les deux nœuds est inférieur à la durée des segments précédents.
\item Si la durée des segments précédents est prévisible (fixe).
\end{itemize} 

\subparagraph{Processus}
Soit $s$ le segment à déplacer, sur un nœud $N_d$.

On déclare une fonction \texttt{deplacement(Segment1, Segment2, Nœud)} (déplacement de \texttt{Segment2} sur \texttt{Nœud} par rapport à \texttt{Segment1}) que l'on définit comme suit :
~ \\
Pour tout segment $p \in \pre(s)$:
\begin{itemize}
\item {Si $p$ et $s$ sont sur le même nœud $N \neq N_d$ :

On considère $E_{p}$ l'ensemble des places d'entrées de $p$.
On note $t_p$ la durée de la transition de $p$.

\begin{itemize}
\item Si $p$ n'est pas précédé par un $\alpha$-segment, on en crée un de la manière décrite précédemment, en \ref{section:alphasegment}.
\item On rajoute en sortie de cet $\alpha$-segment une place $e_s$.
\end{itemize}
\vspace{1em}

On crée ensuite une transition $T_s$ de durée $t_p - \delta_{N \rightarrow N_d}$ (avec un minimum de 0), à laquelle on rajoute en entrée la place $e_s$ créée précédemment. On déplace $s$ de telle sorte que la place de $\shared(p, s)$ soit maintenant en sortie de $T_s$.
L'ensemble composé des places $e_s$, de $T_s$, et de la place d'entrée de $s$ est un $\beta$-segment : c'est le segment qui effectue la bufferisation.

Néanmoins, la place qui était en sortie de la transition de $p$ et partagée avec $s$ est conservée, comme dans la méthode précédente. De cette manière, on peut garder la position originale pour l'opération de recombinaison.
~ \\

C'est le résultat de \texttt{deplacement(p, s, Nd)} lorsque $s$ et $p$ ont même nœud initial.

Un exemple partiel est fourni en figure \ref{fig:deplacementForm2}.
}
\\
\item{ Si $p$ est sur un nœud $N_1$, $s$ sur un nœud $N_2 \neq N_1$, et que $N_d \neq N_1$, comme il y a déjà eu une opération de déplacement, il suffit d'ajuster le temps de la transition $T_s$, qui vaut $t_p - \delta_{N_1 \rightarrow N_2}$ : on ajoute $\delta_{N_1 \rightarrow N_2}$ et on enlève le nouveau délai entre les deux nœuds, $\delta_{N_1 \rightarrow N_d}$.

~ \\
C'est le résultat de \texttt{deplacement(p, s, Nd)} lorsque $s$ et $p$ n'ont pas même nœud initial.
}
\\
\item Si $p$ est sur un nœud $N$, et que $N_d = N$, on effectue une opération de recombinaison : toutes les places de sortie de $p$ qui avaient été préservées dans le premier cas de déplacement sont fusionnées avec les places réelles, et le $\beta$-segment correspondant à ce déplacement est supprimé. S'il n'est plus suivi d'aucun $\beta$-segment, on peut aussi supprimer l'$\alpha$-segment précédant $p$.
~ \\
~ \\
C'est le résultat de \texttt{deplacement(p, s, Nd)} lorsque $N_d$ est le nœud de $p$.
\end{itemize}

On applique ensuite la même transformation entre $s$ et les segments appartenant à $\post(s)$.

\subparagraph{Choix de répartition}
Deux choix sont possibles pour la répartition : 

\begin{itemize}
\item Exécuter $T_s$, la transition du $\beta$-segment, sur le nœud d'origine.
\item Exécuter $T_s$ sur le nœud ou est déplacé $s$.
\end{itemize}

Dans le premier cas, on attend jusqu'au dernier moment pour envoyer le message, dans le second, on l'envoie au plus tôt. Selon les applications, les deux approches peuvent avoir leur intérêt.

Par exemple, on peut préférer la deuxième approche si le lien de connexion est peu stable. On peut préférer la première approche si des évènements venaient à modifier le réseau de Petri pendant l'exécution.


\begin{figure}[H]
\centering
\input{formalisation/figures/deplacement2}
\caption{Exemple : seconde méthode de déplacement}
\label{fig:deplacementForm2}
\end{figure}

Sur la figure \ref{fig:deplacementForm2}, on n'a appliqué \texttt{deplacement} qu'au segment précédent, et non au segment suivant.

On y montre comment on déporte l'exécution du segment $B(B_1, T_B, C_1)$.

\paragraph{Duplication}
L'opération de duplication consiste à faire s'exécuter un nd-segment $s$ sur plusieurs nœuds de $G$ (distincts?). Il faut donc le recopier.

Cette opération revient à la suite d'opérations suivantes : 
\begin{enumerate}
\item Dupliquer localement $s$ : \\
		On crée un nouveau segment similaire à $s$ (même nombre de places, transitions, même durée, mêmes processus et évènements).
		
		Des arcs sont créés dans les segments précédant et suivant $s$ pour répliquer le comportement de $s$, en un nouveau segment $s'$.
\item Déplacer $s'$ avec une des méthodes vues précédemment.
\end{enumerate}

Un cas de duplication pour la seconde méthode est donné en exemple en figure \ref{fig:duplicationEtRecoll}.

\section{Méthode par coloration}
\chaptermark{Coloration}
Cette formalisation utilise la notion de coloration du réseau.

Chaque nœud de $G$ se voit associer une couleur distincte.

\subsection{Généralités}
Les places et les transitions du réseau de Petri peuvent aussi être colorés avec ces mêmes couleurs. Elles peuvent avoir plusieurs couleurs.
À l'état initial, le réseau entier est coloré avec la couleur du premier nœud.

Si une transition est sensibilisée (elle possède un jeton de couleur $c$ dans toutes ses places d'entrée), elle adopte le comportement suivant : 

Pour chaque place en sortie :
\begin{enumerate}
\item Elle compare la couleur $c$ avec la couleur $d$ de la place. 
\item Soit $N_1$ le nœud qui possède la couleur $c$, $N_2$ le nœud qui possède la couleur $d$. Soit $\delta$ le délai entre $N_1$ et $N_2$. Soit $t$ la durée de la transition. La transition s'exécute pour ce jeton avec la durée $t - \delta$, avec un minimum de 0, en gardant en mémoire les jetons qui doivent s'exécuter plus tard.
\end{enumerate}

\subsubsection{Exécution d'une transition}
L'exécution d'une transition présente de plus la particularité suivante : comme une place peut avoir plusieurs couleurs, si une transition doit placer un jeton dans une place, elle y dépose pour chaque couleur de la place, un jeton de cette couleur. 
Une transition est exécutée par le nœud de sa couleur.

\subsection{Opérations sur segment}
\subsubsection{Déplacement}
On change la couleur de la transition et des places d'entrée du segment que l'on désire déplacer.

\subsubsection{Duplication}
Cette opération est similaire au déplacement : au lieu de changer la couleur, on en ajoute une. Si on désire enlever un nœud, il suffit de supprimer une couleur.

Un exemple est donné en figure \ref{fig:repartCouleur}.

\subsection{Problèmes}
Cette méthode présente plusieurs faiblesses : 
\begin{itemize}
	\item Elle change l'algorithme d'exécution, ce qui peut poser des problèmes de compatibilité.
	\item L'utilisation de la couleur fait que cette dernière ne peut pas être utilisée facilement dans d'autres extensions du formalisme \ac{OSSIA}, comme par exemple dans le cas du traitement de données\cite{arias2014modelling}.
	\item Il n'y a pas de moyen facile de re-synchroniser plusieurs machines dans le cas de la duplication.
\end{itemize}

\begin{figure}[H]
	\centering
	\input{formalisation/figures/deplacementCol}
	\caption{Exemple : répartition par couleur} 
	\label{fig:repartCouleur}
\end{figure}

\newpage
\section{Comparaison entre les méthodes}
Dans cette partie, nous faisons une brève comparaison entre les méthodes vues jusqu'à présent, en considérant les qualités et les défauts de chacune, en \cref{tblcompMethods}.

\begin{table}[h]
	\centering
	\tabulinesep=3pt
	\begin{tabu}  to \linewidth {X[0.1,c]XXX}
		& Méthode 1 & Méthode 2 & Méthode 3 \\
		\toprule
		\multirow{5}{*}{{\textbf{\huge $+$}}}
			& Transformation simple & Conserve les nd-segments & Ne change pas la topologie \\
			& & Passe bien à l'échelle & Passe bien à l'échelle \\
			& & Permet effets particuliers (cf. \ref{section:canon}) & Théorie simple \\
			& & Permet rétropropagation (cf. \ref{section:retropropag}) & \\
			& & Permet synchronisation (cf. \ref{fig:duplicationEtRecoll}) &  \\
			\hline
		\multirow{3}{*}{{\textbf{\huge $-$}}} 
			& Passe mal à l'échelle & Transformation complexe & Change l'algorithme \\
			& nd-segments découpés  & Introduit de nouveaux segments & Bloque les couleurs  \\
			& Boucles ingérables & & 
	\end{tabu}
	\caption{Points positifs et négatifs des méthodes}
	\label{tblcompMethods}
\end{table}

En raison du nombre de points positifs de la méthode 2, et de la durée du stage, c'est celle qui a été principalement retenue pour vérifications ultérieures.

\input{formalisation/ameliorations2f}